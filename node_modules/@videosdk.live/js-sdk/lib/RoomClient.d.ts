export default class RoomClient {
    /**
     * @param  {Object} data
     * @param  {Object} data.store - The Redux store.
     */
    static init(data: {
        store: any;
    }): void;
    constructor({ roomId, peerId, secret, displayName, device, handlerName, useSimulcast, useSharingSimulcast, forceTcp, mode, forceH264, forceVP9, svc, datachannel, externalVideo, micEnabled, webcamEnabled, maxResolution, useSpartialLayerAnalytics, _deviceInfo, customCameraVideoTrack, customMicrophoneAudioTrack, autoConsume, preferredProtocol, }: {
        roomId: any;
        peerId: any;
        secret: any;
        displayName: any;
        device: any;
        handlerName: any;
        useSimulcast: any;
        useSharingSimulcast: any;
        forceTcp: any;
        mode: any;
        forceH264: any;
        forceVP9: any;
        svc: any;
        datachannel: any;
        externalVideo: any;
        micEnabled: any;
        webcamEnabled: any;
        maxResolution: any;
        useSpartialLayerAnalytics: any;
        _deviceInfo: any;
        customCameraVideoTrack: any;
        customMicrophoneAudioTrack: any;
        autoConsume: any;
        preferredProtocol: any;
    });
    useSpartialLayerAnalytics: any;
    _deviceInfo: any;
    _eventEmitter: EventEmitter;
    _closed: boolean;
    _displayName: any;
    _device: any;
    _forceTcp: any;
    _preferredProtocol: any;
    _mode: any;
    _produce: boolean;
    _consume: boolean;
    _useDataChannel: any;
    _forceH264: boolean;
    _forceVP9: boolean;
    _micEnabled: boolean;
    _webcamEnabled: boolean;
    _externalVideo: HTMLVideoElement;
    _externalVideoStream: any;
    _nextDataChannelTestNumber: number;
    _handlerName: any;
    _useSimulcast: any;
    _useSharingSimulcast: any;
    _protooUrl: string;
    _secret: any;
    _peerId: any;
    _roomId: any;
    _baseUrl: string;
    _protoo: any;
    _mediasoupDevice: mediasoupClient.types.Device;
    _sendTransport: mediasoupClient.types.Transport;
    _recvTransport: mediasoupClient.types.Transport;
    _micProducer: mediasoupClient.types.Producer;
    _webcamProducer: mediasoupClient.types.Producer;
    _shareProducer: mediasoupClient.types.Producer;
    _shareAudioProducer: mediasoupClient.types.Producer;
    _chatDataProducer: mediasoupClient.types.DataProducer;
    _botDataProducer: mediasoupClient.types.DataProducer;
    _consumers: Map<any, any>;
    _dataConsumers: Map<any, any>;
    _mics: Map<any, any>;
    _mic: {
        device: any;
    };
    _webcams: Map<any, any>;
    _webcam: {
        device: any;
        resolution: any;
    };
    _pinnedParticipants: Map<any, any>;
    _usageIntervalDuration: number;
    _usageDataPointsPeerMaxRes: Map<any, any>;
    _audioConsumption: number;
    customCameraVideoTrack: any;
    customMicrophoneAudioTrack: any;
    _autoConsume: any;
    _iceServers: any[];
    _metrics: any;
    _collectStats: boolean;
    _stats: {};
    _latestStats: {};
    _isWebsocketAlive: boolean;
    _pingWebsocketInterval: NodeJS.Timer;
    _pingInternetInterval: NodeJS.Timer;
    _pingWebsocketFailedCounter: number;
    _pongInternetCounter: number;
    _transportState: string;
    /**
     *
     * @param {
        'ADD_PEER' | 'REMOVE_PEER' |
        'ADD_PRODUCER' | 'REMOVE_PRODUCER' |
        'ADD_CONSUMER' | 'REMOVE_CONSUMER' |
        'SET_ROOM_ACTIVE_SPEAKER' | 'CHAT_MESSAGE' |
        'ENTRY_REQUESTED' | 'ENTRY_RESPONDED' |
        'RECORDING_STARTED' | 'RECORDING_STOPPED' | 'RECORDING_STATE_CHANGED' |
        'LIVESTREAM_STARTED' | 'LIVESTREAM_STOPPED' |
        'WHITEBOARD_STARTED' | 'WHITEBOARD_STOPPED' |
        'VIDEO_STATE_CHANGED' | 'VIDEO_SEEKED' |
        'VIDEO_QUALITY_CHANGED' |
        'WEBCAM_REQUESTED' | 'MIC_REQUESTED' | 'PARTICIPANT_MEDIA_STATE_CHANGED' |  'MEETING_STATE_CHANGED'
      } eventType
     * @param {*} listener
     */
    on(eventType: 'ADD_PEER' | 'REMOVE_PEER' | 'ADD_PRODUCER' | 'REMOVE_PRODUCER' | 'ADD_CONSUMER' | 'REMOVE_CONSUMER' | 'SET_ROOM_ACTIVE_SPEAKER' | 'CHAT_MESSAGE' | 'ENTRY_REQUESTED' | 'ENTRY_RESPONDED' | 'RECORDING_STARTED' | 'RECORDING_STOPPED' | 'RECORDING_STATE_CHANGED' | 'LIVESTREAM_STARTED' | 'LIVESTREAM_STOPPED' | 'WHITEBOARD_STARTED' | 'WHITEBOARD_STOPPED' | 'VIDEO_STATE_CHANGED' | 'VIDEO_SEEKED' | 'VIDEO_QUALITY_CHANGED' | 'WEBCAM_REQUESTED' | 'MIC_REQUESTED' | 'PARTICIPANT_MEDIA_STATE_CHANGED' | 'MEETING_STATE_CHANGED', listener: any): void;
    close({ sendLeft }: {
        sendLeft?: boolean;
    }): void;
    join(): Promise<void>;
    requestEntry(): Promise<void>;
    respondEntry(peerId: any, decision: any): Promise<void>;
    startRecording(webhookUrl: any, awsDirPath: any, config: any): Promise<void>;
    stopRecording(): Promise<void>;
    startLivestream(outputs: any, config: any): Promise<void>;
    stopLivestream(): Promise<void>;
    startHls(config: any): Promise<void>;
    stopHls(): Promise<void>;
    startWhiteboard(): Promise<void>;
    stopWhiteboard(): Promise<void>;
    pinStateChange({ peerId, state }: {
        peerId: any;
        state: any;
    }): Promise<void>;
    startVideo({ link }: {
        link: any;
    }): Promise<void>;
    stopVideo(): Promise<void>;
    pauseVideo(currentTime: any): Promise<void>;
    resumeVideo(): Promise<void>;
    seekVideo(currentTime: any): Promise<void>;
    enablePeerMic(peerId: any): Promise<void>;
    disablePeerMic(peerId: any): Promise<void>;
    consumeWebcamStreams(peerId: any): Promise<void>;
    consumeMicStreams(peerId: any): Promise<void>;
    stopConsumingMicStreams(peerId: any): Promise<void>;
    stopConsumingWebcamStreams(peerId: any): Promise<void>;
    changeMode(requestedMode: any): Promise<void>;
    enablePeerWebcam(peerId: any): Promise<void>;
    disablePeerWebcam(peerId: any): Promise<void>;
    enableMic(customAudioTrack?: any): Promise<void>;
    disableMic(): Promise<void>;
    muteMic(): Promise<void>;
    unmuteMic(): Promise<void>;
    enableWebcam(customVideoTrack?: any): Promise<void>;
    disableWebcam(): Promise<void>;
    /**
     *
     * @returns {Array<{deviceId: string, label: string}>}
     */
    getMics(): Array<{
        deviceId: string;
        label: string;
    }>;
    changeMic(object: any): Promise<void>;
    /**
     *
     * @returns {Array<{deviceId: string, label: string, facingMode: "environment" | "front"}>}
     */
    getWebcams(): Array<{
        deviceId: string;
        label: string;
        facingMode: "environment" | "front";
    }>;
    changeWebcam(object: any): Promise<void>;
    changeWebcamResolution(): Promise<void>;
    enableShare(customScreenSharingTrack: any): Promise<void>;
    disableShare(): Promise<void>;
    enableAudioOnly(): Promise<void>;
    disableAudioOnly(): Promise<void>;
    muteAudio(): Promise<void>;
    unmuteAudio(): Promise<void>;
    restartIce(): Promise<void>;
    setMaxSendingSpatialLayer(spatialLayer: any): Promise<void>;
    /**
     *
     * @param {"low" | "med" | 'high'} quality
     */
    setWebcamQuality(quality: "low" | "med" | 'high'): Promise<void>;
    /**
     *
     * @param {"low" | "med" | 'high'} quality
     */
    setConsumerQuality(consumerId: any, quality: "low" | "med" | 'high'): Promise<void>;
    setViewPort(consumer: any, viewportWidth: any, viewportHeight: any): Promise<void>;
    setConsumerPreferredLayers(consumerId: any, spatialLayer: any, temporalLayer: any): Promise<void>;
    setConsumerPriority(consumerId: any, priority: any): Promise<void>;
    requestConsumerKeyFrame(consumerId: any): Promise<void>;
    enableChatDataProducer(): Promise<void>;
    enableBotDataProducer(): Promise<void>;
    sendChatMessage(text: any): Promise<void>;
    sendBotMessage(text: any): Promise<void>;
    changeDisplayName(displayName: any): Promise<void>;
    openConnection({ roomId, payload }: {
        roomId: any;
        payload: any;
    }): Promise<void>;
    closeConnection(roomId: any): Promise<void>;
    switchTo({ roomId, peerIds, payload }: {
        roomId: any;
        peerIds: any;
        payload: any;
    }): Promise<void>;
    switchPeerRoom({ peerId, roomId, payload, token }: {
        peerId: any;
        roomId: any;
        payload: any;
        token: any;
    }): Promise<void>;
    connectionSwitchPeerRoom({ roomId, connectionRoomId, peerId, payload, token, }: {
        roomId: any;
        connectionRoomId: any;
        peerId: any;
        payload: any;
        token: any;
    }): Promise<void>;
    connectionSendChatMessage({ roomId, message }: {
        roomId: any;
        message: any;
    }): Promise<void>;
    connectionEndMeeting({ roomId }: {
        roomId: any;
    }): Promise<void>;
    pubsubPublish(topic: any, message: any, options: any): Promise<void>;
    pubsubSubscribe(topic: any): Promise<any>;
    pubsubUnsubscribe(topic: any): Promise<void>;
    closeRoom(): Promise<void>;
    removePeer(peerId: any): Promise<void>;
    startPingPong(): Promise<void>;
    pingWebSocket(): Promise<void>;
    delay: (ms: any) => Promise<any>;
    startInternetPingPong(): Promise<void>;
    pingInternet(): Promise<void>;
    getSendTransportRemoteStats(): Promise<any>;
    getRecvTransportRemoteStats(): Promise<any>;
    /**
     *
     * @returns {Promise<[{
     *   bitrate: number,
     *   roundTripTime: number,
     *   jitter: number,
     *   totalPackets: number,
     *   packetsLost: number,
     *   network: String,
     *   codec: String,
     * }]>}
     */
    getAudioRemoteStats(): Promise<[
        {
            bitrate: number;
            roundTripTime: number;
            jitter: number;
            totalPackets: number;
            packetsLost: number;
            network: string;
            codec: string;
        }
    ]>;
    /**
     *
     * @returns {Promise<[{
     *   bitrate: number,
     *   roundTripTime: number,
     *   jitter: number,
     *   totalPackets: number,
     *   packetsLost: number,
     *   network: String,
     *   codec: String,
     *   limitaion: Object,
     *   size: Object
     * }]>}
     */
    getVideoRemoteStats(): Promise<[
        {
            bitrate: number;
            roundTripTime: number;
            jitter: number;
            totalPackets: number;
            packetsLost: number;
            network: string;
            codec: string;
            limitaion: any;
            size: any;
        }
    ]>;
    /**
     *
     * @returns {Promise<[{
     *   bitrate: number,
     *   roundTripTime: number,
     *   jitter: number,
     *   totalPackets: number,
     *   packetsLost: number,
     *   network: String,
     *   codec: String,
     *   limitaion: Object,
     *   size: Object
     * }]>}
     */
    getShareRemoteStats(): Promise<[
        {
            bitrate: number;
            roundTripTime: number;
            jitter: number;
            totalPackets: number;
            packetsLost: number;
            network: string;
            codec: string;
            limitaion: any;
            size: any;
        }
    ]>;
    /**
     *
     * @param {string} consumerId
     * @returns {Promise<[{
     *   bitrate: number,
     *   rtt: number,
     *   network:String,
     *   codec: String,
     *   jitter: number,
     *   totalPackets: number,
     *   packetsLost: number,
     *   concealmentEvents: number,
     *   insertedSamplesForDecelaration: number,
     *   removedSamplesForAccelaration: number,
     *   size:Object
     * }]>}
     */
    getConsumerRemoteStats(consumerId: string): Promise<[
        {
            bitrate: number;
            rtt: number;
            network: string;
            codec: string;
            jitter: number;
            totalPackets: number;
            packetsLost: number;
            concealmentEvents: number;
            insertedSamplesForDecelaration: number;
            removedSamplesForAccelaration: number;
            size: any;
        }
    ]>;
    getChatDataProducerRemoteStats(): Promise<any>;
    getBotDataProducerRemoteStats(): Promise<any>;
    getDataConsumerRemoteStats(dataConsumerId: any): Promise<any>;
    getSendTransportLocalStats(): Promise<RTCStatsReport>;
    getRecvTransportLocalStats(): Promise<RTCStatsReport>;
    getAudioLocalStats(): Promise<RTCStatsReport>;
    getVideoLocalStats(): Promise<RTCStatsReport>;
    getConsumerLocalStats(consumerId: any): Promise<any>;
    applyNetworkThrottle({ uplink, downlink, rtt, secret }: {
        uplink: any;
        downlink: any;
        rtt: any;
        secret: any;
    }): Promise<void>;
    resetNetworkThrottle({ silent, secret }: {
        silent?: boolean;
        secret: any;
    }): Promise<void>;
    createProducerTransport(transportInfo: any): void;
    createConsumerTransport(transportInfo: any): void;
    joinRoom(): Promise<void>;
    _usageInterval: NodeJS.Timer;
    _updateUsageStats(params: any): Promise<void>;
    _updateMics(): Promise<void>;
    _updateWebcams(): Promise<void>;
    _getWebcamType(device: any): "front" | "back";
    _pauseConsumer(consumer: any): Promise<void>;
    _resumeConsumer(consumer: any): Promise<void>;
    _getExternalVideoStream(): Promise<any>;
    _getRoundedResolution(resolution: any): any;
    _getResolutionFromSpatialLayer(spatialLayer: any): 180 | 360 | 720 | 1080;
    _emitError(error: any): void;
}
import { EventEmitter } from "events";
import * as mediasoupClient from "mediasoup-client";
//# sourceMappingURL=RoomClient.d.ts.map